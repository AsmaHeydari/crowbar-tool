module Generics;




data Type = Type1 | Type2;

[Ensures(result != Just(Nothing))]
def Maybe<Maybe<Int>> trivialFunction(Int x) = Just(Just(1));

    //todo: uncomment when support for fst is added
//[Spec: Ensures(fst(result)!=0)]
def Pair<Int,Int> pairFuncSimpleSuccess(Int d, Pair<Int,Int> current) =
    case d {
        1 =>  Pair(1, 1);
        _ =>  Pair(2, 2);
    };

    //todo: uncomment when support for fst/snd is added
//[Spec: Ensures(fst(result)==snd(result))]
//  def Pair<Int,Int> pairFuncWrappedSimpleSuccess(Int d, Pair<Int,Int> current) =
//      case d {
//         1 =>  Pair(fst(current), fst(current));
//         _ =>  Pair(snd(current), snd(current));
//      };


class MaybeClass(Maybe<Int> f, Type f1, Int fi) {

    [Ensures(Just(1) == Just(1))]
    Unit trivialSuccess (){
    }

    [Ensures(Just(result) == Just(1))]
    Int trivialWrapResultSuccess (){
        return 1;
    }

    [Requires(i == 0)]
    [Ensures(Just(result + 1) == Just(1))]
    Int wrapExpressionSuccess (Int i){
        return i;
    }

    [Ensures(Just(1)== this.f)]
    Unit updateFieldTrivialSuccess(){
        this.f = Just(1);
    }

    [Ensures(Just(result)== this.f)]
    Int updateFieldWrapSuccess(){
        this.f = Just(1);
        return 1;
    }

    [Requires(Nothing == this.f)]
    [Ensures(result != Just(this.f))]
    Maybe<Maybe<Int>> trivialFunctionSuccess(){
        return trivialFunction(3);
    }

    [Ensures(result != Just(this.f1))]
    Maybe<Type> caseSuccess(){
        Maybe<Type> res = Just(Type1);
        switch (this.f1) {
            Type1 => res = Just(Type2);
            Type2 => res = Just(Type1);
            _ => skip;
        }
        return res;
    }

    [Requires(this.fi == 0)]
    [Ensures(Just(old(this.fi)) == this.f)]
    Unit wrappedOldSuccess(){
        this.f = Just(0);
    }

    [Ensures(Nothing == result)]
    Maybe<Bool> returnNothingSimpleSuccess(){
        return Nothing;
    }

    [Ensures(Just(Nothing) == Just(result))]
    Maybe<Bool> returnNothingWrapPostSimpleSuccess(){
        return Nothing;
    }


    [Ensures(Just(Just(Nothing)) == Just(Just(result)))]
    Maybe<Maybe<Bool>> returnNothingWrapWrapPostSimpleSuccess(){
        return Nothing;
    }

}

class PairClass(Pair<Type, Bool> f, Type f1, Type f2) {

    [Ensures(Pair(Type1, True) == Pair(Type1, True))]
    Unit trivialSuccess (){
    }

    [Ensures(Pair(result,True) == Pair(Type1, True))]
    Type trivialWrapResultSuccess (){
        return Type1;
    }

    [Requires(i == 0)]
    [Ensures(Pair(result + 1,result-1) == Pair(1,-1))]
    Int wrapExpressionSuccess (Int i){
        return i;
    }

    [Ensures(Pair(Type2, True) == this.f)]
    Unit updateFieldTrivialSuccess(){
        this.f = Pair(Type2, True);
    }

    [Ensures(Pair(Type1,result)== this.f)]
    Bool updateFieldWrapSuccess(){
        this.f = Pair(Type1, True);
        return True;
    }

    [Requires(this.f1 == Type1)]
    [Ensures(Pair(old(this.f1),False) == this.f)]
    Unit wrappedOldSuccess(){
        this.f = Pair(Type1,False);
    }

    //todo: uncomment when support for fst is added
//    [Ensures(fst(this.f) == Type1)]
    Unit fstSimpleSuccess(){
        this.f = Pair(Type1,False);
    }

    //todo: uncomment when support for fst is added
//    [Requires(fst(p) == Type1)]
//    [Ensures(result == Type1)]
//    Type fstParamSuccess(Pair<Type,Bool> p){
//        return fst(p);
//    }

    //todo: uncomment when support for snd is added
//    [Ensures(snd(this.f) == False)]
    Unit sndSimpleSuccess(){
        this.f = Pair(Type1,False);
    }

    //todo: uncomment when support for snd is added
//    [Requires(snd(p) == False)]
    [Ensures(result == False)]
    Bool sndParamSuccess(Pair<Int,Bool> p){
        return snd(p);
    }

}

class ListClass(List<Type> list, Type ft){

   [Ensures(Cons(Type1, Nil) == Cons(Type1, Nil))]
   Unit trivialSuccess (){
   }

   [Ensures(Cons(result,Nil) == Cons(Type1, Nil))]
   Type trivialWrapResultSuccess (){
       return Type1;
   }

   [Requires(i == 0)]
   [Ensures(Cons(result + 1,Nil) == Cons(1,Nil))]
   Int wrapExpressionSuccess (Int i){
       return i;
   }

   [Ensures(Cons(Type2, Nil) == this.list)]
   Unit updateFieldTrivialSuccess(){
       this.list = Cons(Type2, Nil);
   }

   [Ensures(Cons(Type1, Cons(result, Nil))== this.list)]
   Type updateFieldWrapSuccess(){
       this.list = Cons(Type1, Cons(Type1, Nil));
       return Type1;
   }

    [Requires(this.ft == Type2)]
    [Ensures(Cons(old(this.ft),Nil) == this.list)]
    Unit wrappedOldSuccess(){
        this.list = Cons(Type2, Nil);
    }

    [Spec: Requires(x == Cons(1, Nil))]
    [Spec: Ensures(result == 1)]
    Int headSimpleSuccess(List<Int> x){
        Int res = head(x);
        return res;
    }

    [Spec: Requires(x == Cons(1, Cons(2, Nil)))]
    [Spec: Ensures(result == Cons(2, Nil))]
    List<Int> tailSimpleSuccess(List<Int> x){
        List<Int> res = tail(x);
        return res;
    }

    [Spec: Requires(x == Cons(1, Cons(2, Nil)))]
    [Spec: Ensures(result == 2)]
    Int headTailSimpleSuccess(List<Int> x){
        Int res = head(tail(x));
        return res;
    }


    [Ensures(result== Nil)]
    List<Int> returnNilSuccess(){
        return Nil;
    }

}

class TripleClass(Triple<Type,Int,Bool> triple,Int fi){

    [Ensures(Triple(Type1,3,Type1) == Triple(Type1,3,Type1))]
    Unit trivialSuccess (){
    }

    [Ensures(Triple(result,3,result) == Triple(Type1, 3,Type1))]
    Type trivialWrapResultSuccess (){
        return Type1;
    }


   [Requires(i == 0)]
   [Ensures(Triple(result + 1,0,Type1) == Triple(1,0,Type1))]
   Int wrapExpressionSuccess (Int i){
       return i;
   }

   [Ensures(Triple(Type1, 0,False) == this.triple)]
    Unit updateFieldTrivialSuccess(){
        this.triple = Triple(Type1, 0,False);
    }

    [Requires(this.fi == 0)]
    [Ensures(Triple(Type1, old(this.fi),False) == this.triple)]
    Unit wrappedOldSuccess(){
        this.triple = Triple(Type1, 0,False);
    }
    //todo: uncomment when support for fstT is added
    //[Ensures(fstT(this.triple) == Type1)]
    Unit fstTSimpleSuccess(){
        this.triple = Triple(Type1,1,False);
    }
    //todo: uncomment when support for fstT is added
    //[Requires(fstT(p) == Type1)]
    //[Ensures(result == Type1)]
//    Type fstTParamSuccess(Triple<Type,Int,Bool> p){
//        return fstT(p);
//    }

    //todo: uncomment when support for sndT is added
    //[Ensures(sndT(this.triple) == 1)]
    Unit sndTSimpleSuccess(){
        this.triple = Triple(Type1,1,False);
    }

    //todo: uncomment when support for sndT is added
    //[Requires(sndT(p) == 1)]
    //[Ensures(result == 1)]
//    Int sndTParamSuccess(Triple<Type,Int,Bool> p){
//        return sndT(p);
//    }

    //todo: uncomment when support for trdT is added
    //[Ensures(trdT(this.triple) == False)]
    Unit trdTSimpleSuccess(){
        this.triple = Triple(Type1,1,False);
    }

    //todo: uncomment when support for trdT is added
    //[Requires(trdT(p) == False)]
    //[Ensures(result == False)]
    Bool trdTParamSuccess(Triple<Type,Int,Bool> p){
        return trdT(p);
    }

}



{
}
